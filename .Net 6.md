## .Net 6

- Single runtime for mobile, Web, IoT, games, and many other targets,.

  

![image-20220529151149467](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20220529151149467.png)

- Supported OS Versions
  - https://github.com/dotnet/core/blob/main/release-notes/6.0/supported-os.md
- Installation : [Download .NET 6.0 (Linux, macOS, and Windows) (microsoft.com)](https://dotnet.microsoft.com/en-us/download/dotnet/6.0)
- If you have Visual Studio 2022 installed, you might already have it up and running.
- By opening a Powershell prompt and typing the following command, we can determine what version of.NET we are currently running.
  - 

```
:> dotnet --version
```

- .NET 6 runs everywhere, from Windows to the Web, Linux, and mobile and embedded devices
- .NET 6 contains two default runtimes
  - Mono
    - Default runtime for running on a Non Windows-based operating system
  - CoreCLR
    - The CoreCLR is the .NET 6 version of the classic CLR
    - Common Language Runtime (desktop application, web application, or console app)used for running .NET code on Windows
  - WinRT 
    - Runtime used for Universal Windows Platform Applications, or UWP
    - UWP was created with the intention of allowing developers to "build once, run on all Windows 10 devices"(computers, tablets, smartphones, Xbox, Hololens, and embedded devices).
    - WinRT isn't a runtime in the traditional sense. It's more of a user interface for the Win32 API.
  - The .NET 6 runtimes are open source and available at  : https://github.com/dotnet/runtime.



### Execution Process

---

- Compile Source Code  to the Microsoft Intermediate Language, or MSIL
- Compile MSIL Code to Native Code 
  - Using the Just-In-Time, or JIT compiler
    - Compile on Demand during execution , store the compiled code and resuse
  - Using .NET’s ahead-of-time compiler called CoreRT
    -  Translation of the entire set of MSIL instructions into native code during program installation.
    - In .NET AOT compilation is handled by a tool called the native image generator, or Ngen



### Architecture

---

![image-20220529155524817](E:\.net 6\image-20220529155524817.png)



#### Target Framework Moniker (TFM)

----

```xml
setting the Target Framework Moniker or TFM to .NET 6 with Windows support and the UseWPF tag in the csproj file that adds support for WPF in a .NET 6 project.


Adding WPF support

<Project Sdk="Microsoft.NET.Sdk">
	<PropertyGroup>
		<OutputType>WinExe</OutputType>
		<TargetFramework>net6.0-windows</TargetFramework>
		<Nullable>enable</Nullable>
		<UseWPF>true</UseWPF>
	</PropertyGroup>
</Project>

Adding WinForms support

<Project Sdk="Microsoft.NET.Sdk">
	<PropertyGroup>
		<OutputType>WinExe</OutputType>
		<TargetFramework>net6.0-windows</TargetFramework>
		<UseWindowsForms>true</UseWindowsForms>
</Project>
```



##### NET 6 includes the following TFMs:

-  net6.0
- net6.0-Android
-  net6.0-ios
-  net6.0-macos
-  net6.0-maccatalyst
-  net6.0-tvos
-  net6.0-Windows



#### CLI

---

https://docs.microsoft.com/en-us/dotnet/core/tools/.

```
C:\Users\user>dotnet --version
6.0.300

C:\Users\user>dotnet new --list
These templates matched your input:

Template Name                                 Short Name           Language    Tags
--------------------------------------------  -------------------  ----------  --------------------------
ASP.NET Core Empty                            web                  [C#],F#     Web/Empty
ASP.NET Core gRPC Service                     grpc                 [C#]        Web/gRPC
ASP.NET Core Web API                          webapi               [C#],F#     Web/WebAPI
ASP.NET Core Web App                          webapp,razor         [C#]        Web/MVC/Razor Pages
ASP.NET Core Web App (Model-View-Controller)  mvc                  [C#],F#     Web/MVC
ASP.NET Core with Angular                     angular              [C#]        Web/MVC/SPA
ASP.NET Core with React.js                    react                [C#]        Web/MVC/SPA
ASP.NET Core with React.js and Redux          reactredux           [C#]        Web/MVC/SPA
Blazor Server App                             blazorserver         [C#]        Web/Blazor
Blazor WebAssembly App                        blazorwasm           [C#]        Web/Blazor/WebAssembly/PWA
Class Library                                 classlib             [C#],F#,VB  Common/Library
Console App                                   console              [C#],F#,VB  Common/Console
dotnet gitignore file                         gitignore                        Config
Dotnet local tool manifest file               tool-manifest                    Config
EditorConfig file                             editorconfig                     Config
global.json file                              globaljson                       Config
MSTest Test Project                           mstest               [C#],F#,VB  Test/MSTest
MVC ViewImports                               viewimports          [C#]        Web/ASP.NET
MVC ViewStart                                 viewstart            [C#]        Web/ASP.NET
NuGet Config                                  nugetconfig                      Config
NUnit 3 Test Item                             nunit-test           [C#],F#,VB  Test/NUnit
NUnit 3 Test Project                          nunit                [C#],F#,VB  Test/NUnit
Protocol Buffer File                          proto                            Web/gRPC
Razor Class Library                           razorclasslib        [C#]        Web/Razor/Library
Razor Component                               razorcomponent       [C#]        Web/ASP.NET
Razor Page                                    page                 [C#]        Web/ASP.NET
Solution File                                 sln                              Solution
Web Config                                    webconfig                        Config
Windows Forms App                             winforms             [C#],VB     Common/WinForms
Windows Forms Class Library                   winformslib          [C#],VB     Common/WinForms
Windows Forms Control Library                 winformscontrollib   [C#],VB     Common/WinForms
Worker Service                                worker               [C#],F#     Common/Worker/Web
WPF Application                               wpf                  [C#],VB     Common/WPF
WPF Class Library                             wpflib               [C#],VB     Common/WPF
WPF Custom Control Library                    wpfcustomcontrollib  [C#],VB     Common/WPF
WPF User Control Library                      wpfusercontrollib    [C#],VB     Common/WPF
xUnit Test Project                            xunit                [C#],F#,VB  Test/xUnit

```



### C# 6.0 Features



### Nullable Types

---

- A nullable type is denoted with a value type followed by the ? symbol:
- T? translates into System.Nullable<T>. Nullable<T> is a lightweight immutable structure, having only two fields, to represent Value and HasValue

```C#
int? i = null; // OK, Nullable Type
Console.WriteLine (i == null); // True


translates to:
Nullable<int> i = new Nullable<int>();
Console.WriteLine (! i.HasValue); // True


The conversion from T to T? is implicit, and from T? to T is explicit. For example:
int? x = 5; // implicit
int y = (int)x; // explicit

C# also permits the unboxing of nullable types with the as operator. The result will be null if the cast fails:
object o = "string";
int? x = o as int?;
Console.WriteLine (x.HasValue); // False
```



#### Null Coalescing Operator

---

- The ?? operator is the null coalescing operator, and it can be used with both nullable types and reference types.

- It says “If the operand is non-null, give it to me; otherwise, give me a default value.

- The null-coalescing operator `??` returns the value of its left-hand operand if it is not a `null` value. If it is null, then it evaluates the right-hand operand and returns its result.

  

```C#
int? x = null;
int y = x ?? 5; // y is 5
int? a = null, b = 1, c = 2;
Console.WriteLine (a ?? b ?? c); // 1 (first non-null value)
```

#### Caller Info Attributes

---

- [CallerMemberName] applies the caller’s member name
-  [CallerFilePath] applies the path to caller’s source code file
-  [CallerLineNumber] applies the line number in caller’s source code file

```C#
using System;
using System.Runtime.CompilerServices;
class Program
{
	static void Main()
	{
		Foo();
	}
static void Foo ([CallerMemberName] string z = null,[CallerFilePath] string filePath = null,
[CallerLineNumber] int lineNumber = 0)
	{
		Console.WriteLine (memberName);
		Console.WriteLine (filePath);
		Console.WriteLine (lineNumber);
	}
```



#### **Auto-property initializers**

---

```C#
public class Patient
{

    public string MRB { get; } = "MRN"+GUID.NewId();

    public DateTime RegistrationDate { get; } = DateTime.Today;

}

```

#### **Expression Bodied Methods and Auto-Properties**

---

```C#
public TimeSpan Age => DateTime.Now – DateOfBirth;
public override string ToString() => string.Format("{0} is {1} ", MRN, Age);
```

#### **Dictionary initializers**

```
var patientDict = new Dictionary<string, Patient>;
{
	["MRN1"] = new Person("Tom", 28),
	["MRN2"] = new Person("Hary", 25)
};
```

#### Null-Conditional Operator

---



```C#
if (patientList != null)
{
	Patient first = patientList[0];
	int count = patinetList.Count;            
}

//New Syntax
Patient first = patientList?[0];  // null if patientList is null
int? nullableCount = patientList?.Count; // null if patientList is null
int count = personList?.Count ?? 0; // 0 if patientList is null

int length = patient?.Name?.Length ?? 0; 
```



####  String Interpolation

---

```C#
string.Format("Patient MRN :{0} {1} , Name:{2} and Age is:{3}.", MRN, Name,  Age);

string message= $"Patient MRN :{MRN}, Name:{Name} and Age is:{Age}.";


```



#### Using Static

-----

```c#
using static System.Console;
...

...
static void Main(){
 WriteLine("Hello.............");
}

```



#### **The nameof Operator**

----

```C#
operator nameof returns the name of any item like class, method, property or parameter.

public class Patient
{

    public string MRB { get; } = "MRN"+GUID.NewId();

    public DateTime RegistrationDate { get; } = DateTime.Today;

}

static void Main(){
    
    Console.WriteLine(nameof(Patient));
}

```

#### Exception Filters

---

```C#
try
{
	throw new Exception("Test exception");
}
catch (Exception ex) when (ex.Message == "Test exception")
{
	Console.WriteLine("Test exception caught");
}
catch (Exception ex) 
{
	Console.WriteLine("Other exception caught here");
}
```



### C# 7.0 Features

---

#### Out Variables

- The ability to declare a variable right at the point where it is passed as an out argument
- Caller Can Ignore Out Variable using _ (discard ) operator

```C#
public static void Main()
	{
		//out variables
		Console.WriteLine("Hello World");
		string data="1234";
		//preDeclare variable
		//int targetValue;
		ConvertToInt(data,out int targetValue,out int code); // C# 7.0
		ConvertToInt(data,out var _targetValue,out _); //Discard
	}
public static bool ConvertToInt(string input,out int convertedValue,out int code){
		
		convertedValue=0;
		code=0;
		return true;
	}
```



#### Pattern matching

---

- Instead of just a type, is expressions can now have a pattern on the right hand side.
- Switch statement case clauses can now match on patterns rather than just constant values.

```C#
sttaic void Main(){
object obj=GetObject();
		if(obj is null){
			Console.WriteLine("Obj is Null");
		}
		
		else if(obj is Program){
			Console.WriteLine("Obj is of Type Program");
		}
		else if(obj is int x){
			//int x=(int)obj;
			Console.WriteLine($"Obj is of Type Integer and value is {x}" );
		}
		
		/* Is Expressions with Patterns - C# 7.0
		if(obj is int i || obj is string s && .......
		*/
}

	public static void Deploy(Environment env){
		switch(env.Name){
				
			case string s when(s == "Test"):Console.WriteLine($"Test Env Deploy" );break;
			
		}
		
		//_depolyStatergies[env.Name].Invoke();
		
		
	}


static void IfElsePatternMatching()
{
  Console.WriteLine("===If Else Pattern Matching ===/n");
  object testItem1 = 123;
  object testItem2 = "Hello";
  if (testItem1 is string myStringValue1)
  {
    Console.WriteLine(&"{myStringValue1} is a string");
  }
  if (testItem1 is int myValue1)
  {
    Console.WriteLine(&"{myValue1} is an int");
  }
  if (testItem2 is string myStringValue2)
  {
   Console.WriteLine(&"{myStringValue2} is a string");
  }
  if (testItem2 is int myValue2)
  {
   Console.WriteLine(&"{myValue2} is an int");
  }
  Console.WriteLine();

}
```



#### **tuple types and **tuple literals:

---

- A tuple is **a data structure that contains a sequence of elements of different data types**. It can be used where you want to have a data structure to hold an object with properties, but you don't want to create a separate type for it

```C#
(string, string, string) FindPatientName(string  mrn) // tuple return type
{
    ... // retrieve first, middle and last from data storage
    return (first, middle, last); // tuple literal
}

var names = FindPatientName(id);
WriteLine($"found {names.Item1},{names.Item2}, {names.Item3}.");

//Descriptive Items
(string first, string middle, string last) FindPatientName(string mrn) // tuple elements have names
....
var names = FindPatientName(id);
WriteLine($"found {names.first},{names.middle}, {names.last}.");

.....
specify element names directly in tuple literals:

return (first: first, middle: middle, last: last); // named tuple elements in a literal


```



#### Deconstruction

---

- A deconstructing declaration is a syntax for breaking down a tuple (or other value) into its constituent pieces and assigning each portion to a new variable:

  

```
(string first, string middle, string last) = FindPatientName(mrn); // deconstructing declaration
(var first, var middle, var last) = LookupName(id1); // var inside
var (first, middle, last) = LookupName(id1); // var outside

```

#### Deconstructor

---

```C#
class Patient
{
    public string  MRN { get; }
    public string  Name { get; }

    public Point(string  mrn,string  name) { MRN = mrn; Name =name; }
    public void Deconstruct(out string mrn, out  string name) { mrn = MRN; name = Name; }
}


....

(var mrn,var name )= new Patient("MRN100","Tom");

.."discards" in deconstruction....
(var mrn,_ )= new Patient("MRN100","Tom");
```



#### Throw expressions

---

```C#
class Patient
{
    public string MRN { get; }
    
    public Person(string mrn) => MRN = mrn ?? throw new ArgumentNullException(nameof(name));
    
    public string GetName() => throw new NotImplementedException();
}
```



#### Local functions

---



```C#
//Closure Using Local Functions

public static Func<string,bool> CheckStringStartsWithAnyPatterns(string pattern){

      //local Function
      bool Predicate(string item){
      return item.Startswith(pattern);
      }
      
      return Predicate;

}
```

#### ***Digit Separator\***

---

```
//Literal Improvements
var accountNumber = 123_456;

```



#### Ref returns and locals

---

```C#
//ref returns 
	static ref int searchNumber(int[] source,int number){
		
		for(int i=0;i<source.Length;i++){
			if(source[i]==number){
				
				return ref source[i];//value type
			}
		}
		throw new Exception("Element Not Foud");
	}
	
	public static void Main()
	{
		int[] numbers={1,2,345,5,9,7,8};
		ref int result=ref searchNumber(numbers,345);//result->pointer->numbers[2]
		Console.WriteLine("Result : "+result);
		result=1000;
		Console.WriteLine("Change in Result : "+result);
		for(int i=0;i<numbers.Length;i++){
			Console.WriteLine(numbers[i]);
		}
		
	}
```



### private protected member

---

- The `private protected` keyword combination is a member access modifier. A private protected member is accessible by types derived from the containing class, but only within its containing assembly.

```C#
//Assembly AB.dll
public class A
{
    private protected int member= 0;
}

public class B : A
{
    void Access()
    {
        // OK, accessed through the current derived class instance
        member = 5;
    }
}
....
A obj=new A();
obj.member=10; //Error


//Assembly XY.dll
// Compile with: /reference:AB.dll

class C : A
{
    void Access()
    {
        // Error CS0122, because myValue can only be
        // accessed by types in Assembly1
        // member = 10;
    }
}
```



#### Non trailing Named Arguments

```
private static void PrintPatientInfo(string mrn,string name, int age, string address, bool isInsured = default, bool isEmployee = default)
{
    Console.WriteLine("Mrn: {0}, Name: {1}, Age: {2}, Address: {3}, Is Insured: {4}, Is Employee: {5}", mrn,name, age, address, isInsured, isEmployee);
}

public static void Example()
{
    PrintPatientInfo("MRN100",Tom", 24, "BLR");
    PrintPatientInfo("MRN200",John", 31, "CHN", true, false);
    PrintPatientInfo(mrn:"MRN300",name:"Stella", age:29, address:"HYD", isInsured:true, isEmployee:true);
    PrintPatientInfo(mrn:"M400",age:27, address:"BLR", name: "Andy", isEmployee: true, isInsured: true);
}

//Before C# 7.2, it was not allowed to specify the named arguments before positional arguments.
```



### C# 8.0 Features

---

#### Nullable Reference Types

---

- Non-nullability to reference types helps to avoid  NullReferenceExceptions
- Nullable reference types introduce a level of safety that’s enforced purely by the compiler, in the form of warnings when it detects code that’s at risk of generating a NullReferenceException
- Enabling nullable reference types 
  -  #nullable enable directive 
  - <Nullable>enable</Nullable> project setting) 
- It enables the nullable annotation context, which tells the compiler to treat all reference-type variable declarations as non-nullable unless suffixed by the ? symbol.
  • It enables the nullable warning context, which tells the compiler to generate warnings upon encountering code at risk of throwing a NullReferenceException.
- 

```c#
To enable nullable reference types, add the Nullable element to  .csproj project file (if you want to enable it for the entire project):
<PropertyGroup>
<Nullable>enable</Nullable>
</PropertyGroup>


...Code....
#nullable enable // enables nullable reference types from this point on
#nullable disable // disables nullable reference types from this point on
#nullable restore // resets nullable reference types to project setting

#nullable enable // Enable nullable reference types
string s1 = null; // Generates a compiler warning!
string? s2 = null; // OK: s2 is nullable reference type


#nullable disable
string reverse(string s)
{
    return s.ToUpper();
}

Console.WriteLine(reverse(null));

....AOP......
using System.Diagnostics.CodeAnalysis;

PassNullUsingAttribute(null, null);

void PassNullUsingAttribute([AllowNull] string msg, [DisallowNull] string content) { 

}
```

##### Null-forgiving operator (!)

```
void Foo (string? s) => Console.Write (s.Length); //warning generated

void Foo(string? s) => Console.Write(s!.Length);
```

##### Treating Nullable Warnings as Errors

```xml
<PropertyGroup>
<Nullable>enable</Nullable>
<WarningsAsErrors>CS8600;CS8602;CS8603</WarningsAsErrors>
</PropertyGroup>
```

##### Attributes for null-state static analysis

---

https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/attributes/nullable-analysis



### Readonly Instance Members

---



```C#
//Source - https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-8.0/readonly-instance-members
public struct Vector2
{
    public float x;
    public float y;

    public readonly float GetLengthReadonly()
    {
        return MathF.Sqrt(LengthSquared);
    }

    public float GetLength()
    {
       
        return MathF.Sqrt(LengthSquared);
    }

    public readonly float GetLengthIllegal()
    {
        var tmp = MathF.Sqrt(LengthSquared);

        x = tmp;    // Compiler error, cannot write x
        y = tmp;    // Compiler error, cannot write y

        return tmp;
    }

    public readonly float LengthSquared
    {
        get
        {
            return (x * x) +
                   (y * y);
        }
    }
}

public static class MyClass
{
    public static float ExistingBehavior(in Vector2 vector)
    {
        // This code causes a hidden copy, the compiler effectively emits:
        //    var tmpVector = vector;
        //    return tmpVector.GetLength();
        //
        // This is done because the compiler doesn't know that `GetLength()`
        // won't mutate `vector`.

        return vector.GetLength();
    }

    public static float ReadonlyBehavior(in Vector2 vector)
    {
        // This code is emitted exactly as listed. There are no hidden
        // copies as the `readonly` modifier indicates that the method
        // won't mutate `vector`.

        return vector.GetLengthReadonly();
    }
}
```



#### default interface methods

---

- *virtual extension methods*  - methods in interfaces with concrete implementations.
- Default interface methods enable an API author to add methods to an interface in future versions without breaking source or binary compatibility with existing implementations of that interface.
- Adding default interface implementations provides the elements of the "traits" language feature

```C#
//Source: https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/proposals/csharp-8.0/default-interface-methods
interface IA
{
    void M() { WriteLine("IA.M"); }
}

interface IB : IA
{
    void IA.M() { WriteLine("IB.M"); } // Explicit implementation
}
interface IC : IA
{
    void M() { WriteLine("IB.M"); } // Creates a new M, unrelated to `IA.M`. Warning
}

interface ILogger
{
void Log (string text) => Console.WriteLine (Prefix + text);
static string Prefix = ""; //supports static variable
    
}

ILogger.Prefix = "File log: ";
```

##### Reabstraction

```C#
interface IA
{
    void M() { WriteLine("IA.M"); }
}
interface IB : IA
{
    abstract void IA.M();
}
class C : IB { } // error: class 'C' does not implement 'IA.M'.
```

#### using declarations

---

- The lifetime of a `using` local will extend to the end of the scope in which it is declared

```C#
if (...) 
{ 
   using FileStream f = new FileStream(@"C:\users\jaredpar\using.md");
   // statements
}

// Equivalent to 
if (...) 
{ 
   using (FileStream f = new FileStream(@"C:\users\jaredpar\using.md")) 
   {
    // statements
   }

    
    
```

#### static local functions

---

- Support local functions that disallow capturing state from the enclosing scope.
- Locals, parameters, and `this` from the enclosing scope are not available within a `static` local function
- https://github.com/dotnet/csharplang/blob/master/meetings/2018/LDM-2018-09-10.md#static-local-functions

####  Indices and ranges

---

- Indices and ranges are a simple way to access single items or ranges of elements in a sequence.

- In C# 8.0, the following two new types are added.

  - Range

    - The `System.Range` struct represents a range that has start and end indexes.
    - The range operator `..`, which specifies the start and end of a range as its operands.
    - The start of the range is inclusive, but the end of the range is exclusive, meaning the start is included in the range but the end isn't.
    - Ranges let you “slice” an array by using the .. operator

    

  - Index

    - The `System.Index` struct represents a type that can be used to index a collection either from the start or the end.
    - The `^` operator specifies the relative index from the end of an array.

  

```c#
string[] nameOfMonths = { 
                          // index from start    index from end
    "January",            // 0                   ^12
    "February",           // 1                   ^11
    "March",              // 2                   ^10
    "April",              // 3                   ^9
    "May",                // 4                   ^8
    "June",               // 5                   ^7
    "July",               // 6                   ^6
    "August",             // 7                   ^5
    "September",          // 8                   ^4
    "October",            // 9                   ^3
    "November",           // 10                  ^2
    "December"            // 11                  ^1
                          // 12 (nameOfMonths.Length)  ^0
};

List<char> list = ...;
var value = list[^1];

// Gets translated to
var value = list[list.Count - 1];

var names = nameOfMonths[2..5];

foreach (var name in names)
{
    Console.WriteLine(name);
}

Range phrase = 1..3;
Range phrase = ^2..^0;
var names = nameOfMonths[phrase];

var allMonths = nameOfMonths[..];       // contains all names.
var firstTwoMonths = nameOfMonths[..2]; // contains first two names i.e. January and February.
var lastThreeMonths = nameOfMonths[9..];     // contains the last three names.


char[] vowels = new char[] {'a','e','i','o','u'};
char lastElement = vowels [^1]; // 'u'
char secondToLast = vowels [^2]; // 'o'

char[] firstTwo = vowels [..2]; // 'a', 'e'
char[] lastThree = vowels [2..]; // 'i', 'o', 'u'
char[] middleOne = vowels [2..3] // 'i'
char[] lastTwo = vowels [^2..]; // 'o', 'u'
```



#### Null-coalescing Assignment

---

- A new null-coalescing assignment operator `??=` assigns the value of its right-hand operand to its left-hand operand only if the left-hand operand evaluates to null.

- The ??= operator assigns a variable only if it’s null.

  

```C#
 Instead of this:
if (s == null) s = "Hello, world";
you can now write this:
s ??= "Hello, world";

List<int> numList = null;
numList ??= new List<int>() { 34, 71};

Console.WriteLine(string.Join(" ", numList));  // output: 34 71

int? val = null;
numList.Add(val ??= 120);

Console.WriteLine(string.Join(" ", numList));  // output: 34 71 120
Console.WriteLine(val);                        // output: 120
```



#### Switch Expressions

---

```C#
string cardName = cardNumber switch // assuming cardNumber is an int
{
	13 => "King",
	12 => "Queen",
	11 => "Jack",
	_ => "Pip card" // equivalent to 'default'
};

int cardNumber = 12; string suite = "spades";
	string cardName = (cardNumber, suite) switch
	{
		(13, "spades") => "King of spades",
		(13, "clubs") => "King of clubs",
	...
	};
	
	if (obj is string { Length:4 }) ...


```



#### Async Streams

---

- iterate a collection asynchronously

```
private static async IAsyncEnumerable<int> GenerateEvenSequence()
{
    for (int i = 0; i <= 50; i = i + 2)
    {
        await Task.Delay(100);
        yield return i;
    }
}

public static async Task PrintEvenSequenceAsync()
{
    await foreach (var number in GenerateEvenSequence())
    {
        Console.WriteLine(number);
    }
}
```

#### StackAlloc  in nested expressions

---

- The `stackalloc` operator allocates a memory block in the stack. A memory block is created during the execution of the method, and it is automatically deleted when the method is returned.